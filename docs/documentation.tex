\documentclass[pdftex, 11pt]{article}

\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{fullpage}
\usepackage{color}
\usepackage{amsmath}
\usepackage[pdftex,bookmarks=true,colorlinks=true,linkcolor=blue]{hyperref}

%this sets the line at the header
\setlength{\headheight}{15.2pt}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

% This is all for formatting and making the Table of Contents according to 
% spec. Don't play with it.
\makeatletter
\renewcommand\l@section[2]{%
  \ifnum \c@tocdepth >\z@
    \addpenalty\@secpenalty
    \addvspace{1.0em \@plus\p@}%
    \setlength\@tempdima{1.5em}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
      \leavevmode \bfseries
      \advance\leftskip\@tempdima
      \hskip -\leftskip
      #1\nobreak\ 
      \leaders\hbox{$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}
     \hfil \nobreak\hb@xt@\@pnumwidth{\hss #2}\par
    \endgroup
  \fi}
\makeatother



\begin{document}

%import the title page
\input{./title.tex}

%headers, footers, and table of contents
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection}}
\rhead{Page \thepage\ of \pageref{LastPage}}
\lhead{}
\lfoot{CS 302 | Spring 2010}
\cfoot{}
\renewcommand{\footrulewidth}{0.4pt}

\tableofcontents

\listoffigures
\newpage

\lhead{Joshua Gleason \& Josiah Humphrey}
\rhead{Page \thepage\ of \pageref{LastPage}}
\rfoot{Section\ \rightmark}
\cfoot{}
\lfoot{CS 302 | Spring 2010}
\renewcommand{\footrulewidth}{0.4pt}

\section{Introduction}

In this assignment, the students were asked to make an image class that manipulated a Portable Gray Map (PGM) and
Portable Pixmap (PPM) images in various ways. The PPM format was to use a 2D array of a RGB class that the students were to
implement, and the PGM format was stored using a 2D int array.

One of the first problems faced was how to use the supplied read and write image files.  These functions were provided
to simplify the build process as they allowed the students to concentrate on the manipulation of the images. These files
were also changed slightly to accommodate the PPM and PGM file formats and were overloaded to accept either file.

After reading and writing images was mastered, the students undertook the bulk of the assignment which was to manipulate
the images that had been read in with the supplied read function. This required the knowledge of manipulating dynamic 2D
arrays of both the RGB and int classes. 

The assignment also required the use of constructors, destructors, copy constructors, and operator overloading, These
topics were review from CS 202, but the use of them refreshed the students minds on how they work and to their purposes.
The students also ahd to implement these functions for the RGB class.

The students also extensively documented their program and made it as easy as possible to understand what was happening
in the various algorithms that were implemented. The students realize that commenting and documenting the source code
for projects is extremely important and is essential to the success of a powerful programmer.

\section{Use of Code}

The use of the program should be very intuitive. The user must use the arrow keys to scroll in the menu and press enter
to select some option. The main program will first have the student decide to choose if the user wants to edit color or
gray scale images. This is a limitation and was done to prevent the code from becoming too complex. The menu will then
pop up windows and message boxes depending on the user's selection and the user's input. This provides for a very
effective setup and takes the burden out of trying to look at the keyboard and the menu for key choices in a simple
menu. Our menu uses ncurses to accomplish the scrolling menu. The students adapted a ncurses API written by Micheal
Leverington from CS 135 to implement a simple curses menu at the beginning, but after all of the functions were
completed, the students decided to make a more robust menu capable of scrolling. This was not required, but was done for
aesthetic reasons and for the experience that it allowed the students.

The image class that was implemented has all of the requirements for the functions. Each function is defined exactly
like Dr. Bebis wanted them to be defined and the coders adapted their coding style to match what Dr. Bebis expected. The
code is built fairly modular and most of the time expects the class user to bounds and error check before information is
sent to the class. The image class has also been templated. This allows the user to use any image type as long as there
is a read and write function provided. The RGB class was also made to hold the data for the color images. As long as the
read and write functions hold their info in a Red, Green, Blue setup, the image class should be able to handle the
image. There is some rudimentary error checking in the class itself, but it only prevents the most foul and
gross errors. The class is also setup to throw string objects in the case of an error. These thrown strings must be
caught in the driver, so it is up to the class user to implement the catches for these thrown strings. Strings were used
as the errors because of their ease of use and ease of manipulation by the class user. 

The file IO functions that were provided by Dr. Bebis have been combined into a single file pair (.cpp and .h) called
imageIO. This allows a much more unified and modular approach to the use of the image IO features. It also makes
including the functions much easier to include into multiple source files. This file has been modified from the last lab
to have the ability to read and write PPM and PGM files. The PPM functions depend on the RGB class to store the data.

Whenever a new image is needed by the user of the class, the user should always use the setImageInfo function that is
included in the image class. This function takes the rows, columns, and levels and creates a blank image to manipulate.
Another feature of this function is that it creates a checkered background of 25x25 squares that make it easy to see the
dimensions of the image if it is saved without modification. It is also helpful for functions that take an image and
move them somehow. For instance, if an image was translated by 55 pixels, the program user could see that there is 2.2
squares that are uncovered, showing that the images has been translated 55 pixels. This was a design choice that came
about as a result of how other image manipulation programs work and the students attempt at creating a robust image
manipulation resource.

One last area that needs some mention to properly use is the function of operator+. This function includes a coefficient
that determines the weight that each image has when adding them together. The students mimicked Dr. Bebis name for this
coefficient and called it 'a'. When 'a' is large, the first image has more weight in the addition; when 'a' is small,
the second image has more weight, and when 'a' is .5, the images have equal weight in the addition. The coefficient can
be between 0 and 1.

\section{Functions}

\subsection{Image.h}
\begin{description}

	\item{\textsc{dilate}}
		\begin{description}

\begin{lstlisting}
void ImageType<pType>::dilate()
\end{lstlisting}

			\item{Purpose}

				This function changes any pixel to black that is
				touching a black pixel on any of its 8 sides.

			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				Nothing is assumed but it makes sense to
				actually have a defined picture.

		\end{description}

	\item{\textsc{erode}}
		\begin{description}

\begin{lstlisting}
void ImageType<pType>::erode(){
\end{lstlisting}

			\item{Purpose}

				This function changes any pixel to white that is
				touching a white pixel on any of its 8 sides.

			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				Nothing is assumed but it makes sense to
				actually have a defined picture.


		\end{description}

	\item{\textsc{threshold}}
		\begin{description}

\begin{lstlisting}
void ImageType<pType>::threshold(){
\end{lstlisting}

			\item{Purpose}

				Applies this formula to each pixel:
				{\small
				\[
				O(i,j) = 
				\begin{cases} 
					255 & \text{if } I(i,j) > T \\
					0   & \text{if } I(i,j) <= T
				\end{cases}
				\]}

				But must first find the correct value for T by
				using a number derived from the average pixel
				value.


			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				Nothing is assumed but it makes sense to
				actually have a defined picture.

		\end{description}


\end{description}

\subsection{driver.cpp}

\begin{description}

	\item{\textsc{countregions}}

		\begin{lstlisting}
		void countRegions(ImageType<pType> img[], 
			bool loaded[], char name[][NAME_LEN])
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				This prompts the user for the image in which to
				count the number of regions.

			\item{Input}
				
				\begin{itemize}

					\item{img[]}

						The image to be region counted.

					\item{loaded[ ]}

						The bool value that sets whether
						or not the image has been
						loaded.

					\item{name[ ][NAME_LEN]}

						The char array that holds the
						image name.

				\end{itemize}

			\item{Output}
				
				None

			\item{Assumptions}

				Assumes that there has been a image loaded into
				the register, but does not require that. 


		\end{description}

	\item{\textsc{findcomponentsdfs}}

		\begin{lstlisting}

		void findComponentsDFS(ImageType<pType> inputImg, 
			ImageType<pType>& outputImg, int startRow,
			int startCol, pType label)
		\end{lstlisting}

		\begin{description}
			\item{Purpose}

				Uses a depth first search to count regions. Uses
				a stack to fill regions at the deepest point and
				working its way back.

			\item{Input}

				\begin{itemize}

					\item{inputImg}

						The image to have its regions
						counted.

					\item{outputImg}

						The image that will be saved to
						once the original image has had
						its regions counted.

					\item{startRow}

						The row at which to start the
						counting of regions.

					\item{startCol}

						The column at which to start the
						counting of regions.

					\item{label}

						The label to label each region
						as it is counted. Should be
						unique.

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes nothing but it makes sense if there is a
				image that is being counted and that the image
				has a region.


		\end{description}
	\item{\textsc{findcomponentsbfs}}

		\begin{lstlisting}

			void findComponentsBFS(ImageType<pType> inputImg,
				ImageType<pType>& outputImg, int startRow,
				int startCol, pType label)
		\end{lstlisting}

		\begin{description}
			\item{Purpose}

				Uses a breadth first search to count regions. Uses
				a queue to fill regions at the shallowest point
				and works its way from there.

			\item{Input}

				\begin{itemize}

					\item{inputImg}

						The image to have its regions
						counted.

					\item{outputImg}

						The image that will be saved to
						once the original image has had
						its regions counted.

					\item{startRow}

						The row at which to start the
						counting of regions.

					\item{startCol}

						The column at which to start the
						counting of regions.

					\item{label}

						The label to label each region
						as it is counted. Should be
						unique.
				

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes nothing but it makes sense if there is a
				image that is being counted and that the image
				has a region.


		\end{description}
		
	\item{\textsc{findcomponentsrec}}

		\begin{lstlisting}
			void findComponentsRec(const ImageType<pType>& inputImg,
				ImageType<pType>& outputImg,int startRow, 
				int startCol, pType label)
		\end{lstlisting}

		\begin{description}
			\item{Purpose}

				Uses a depth first recursive function search
				that recursively floods the current region with
				the value of the label.

			\item{Input}

				\begin{itemize}

					\item{inputImg}

						The image to have its regions
						counted.

					\item{outputImg}

						The image that will be saved to
						once the original image has had
						its regions counted.

					\item{startRow}

						The row at which to start the
						counting of regions.

					\item{startCol}

						The column at which to start the
						counting of regions.

					\item{label}

						The label to label each region
						as it is counted. Should be
						unique.
				

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes nothing but it makes sense if there is a
				image that is being counted and that the image
				has a region.


		\end{description}



\end{description}

\subsection{queue.h}

\begin{description}

	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}


	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}
	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}
	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}
	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}
	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}
	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}
	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}
	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}
	\item{\textsc{queue}}

		\begin{lstlisting}
			queue();
		\end{lstlisting}

		\begin{description}
			\item{Purpose}
				
				Constructs the queue by setting its two pointers
				to \texttt{NULL}

			\item{Input}

				None

			\item{Output}
				
				None

			\item{Assumptions}

				None

		\end{description}


\section{Bugs and Errors}

	During the creation of this program we ran into a multitude of bugs and errors.  Some of the biggest obstacles came
while implementing the main driver program.  Learning how curses works and finding way to make it do what was needed was
quite a challenge but also very rewarding.  One odd bug was that when the function wattron() was used to set to
highlight for the menu options it worked fine on one computer, but when it was used on Josiah's computer the
highlighting didn't show up.  The fix for this involved manually inverting the colors rather than just changing the
attribute.  This is a good example of how a program may act differently on different computers.

	Another bug that we ran into was having trouble when enlarging images too much.  The way this was dealt with was to add a
global constant to the main driver which limited the size allowed to scale an image.  Although there weren't many actual
bugs while writing the image class, there was a huge amount of testing done to try and make the program as robust as
possible given the time limitation.

	There was another bug the students ran into when rotating color images holes were appearing in the image.  After
spending quite some time searching the problem was finally discovered;  Apparently the implementation of the operator
overloads for the RGB class were actually changing the calling object, so if the same value was used in an equation more
than once it was returning incorrect results.  This problem helped both of the students understand operator overloading
much better, and once this was discovered the rest of the program went smoothly.

\section{What was Learned}

	The most important thing learned in this assignment was the use of templates. This was taught briefly in the previous
semester of CS, so the concept of it was fairly new to the students. This challenge did not sway them though. The
students quickly grasped the concepts of templates and easily implemented it into the image class to use both ints and
RGB values. The students were then able to design the functions that manipulated the 2D array of ints and RGB both, that
in turn manipulated the image. This was an important concept to grasp because without understanding the concepts of a
template, the students would not be able to correctly develop algorithms that correctly manipulate any type of image
format.

	Another concept that the students learned was the knowledge of how images are stored. The students had first hand
experience with an image format and this knowledge allowed the students to have a greater understanding of how computers
and the data structures associated with file formats intertwine with the software developer. The students have more of
an appreciation for the necessity of data structures and the implications of designing easy to use and compact data
structures for the end user. The students also learned how color images can be represented in computers and gained
excellent hands on experience with how they work and how to manipulate them.

	One of the other concepts that the students learned was the ability to use ncurses in their program. This knowledge
allowed the students to create a very easy-to-use menu that is capable of multiple floating and scrollable menus. While
this part of the program was not needed, the students had a desire to learn more about C++ than what is being taught in
the class and brought it upon themselves to learn about ncurses. This knowledge has greatly improved their knowledge of
pointers and correct program structure because ncurses utilizes many pointers. The implementation of ncurses also becomes
very complex if there is not a clean program structure implemented. There are many facets of ncurses that are
intertwined, so the students made a clean and modular ncurses driver that is able to be easily read.

	Since this was a group project, we felt that it would be fairly difficult to merge and maintain our code, so we decided
to learn and use git. Git is a revision control program that focuses on software development. It was developed by Linus
Torvalds for the development of the Linux kernel. Git has proved to be extremely useful in the management of the source
code. It did have a small learning curve, but once that was crossed, it has become one of the most valuable tools that I
know of.

\section{Division of Labor}

	For the requirements that were asked for, each student did an equal amount of work. The students met very early and
divided up the required functions equally. Each student then implemented each function of the image and RGB class. Since
the students are at different levels of programming experience, one of the students went above the required
implementation to challenge himself. Josh implemented some advanced methods of manipulating the image using knowledge
from a numerical methods class that he has taken in the past. Josh also wrote the driver with the help of Josiah for
feedback on how to design the menu system. Both students studied and learned how the curses environment works and
equally experimented with the functionality of curses and its implementation into a menu system. For the documentation,
Josiah wanted to go above the normal implementation of a standard documentation and implemented a \LaTeX document that
made the writing of the documentation very easy and structured. Overall, the students contributed equally for their
level of programming skill.

\section{Extras}

				This section isn't required but we thought that it was important to explain all the
				extra features that were added to this project.  The biggest addition to the project was
				the addition of bi-cubic interpolation for enlargeImage().  This was done by Josh as
				more of a coding challenge, but worked out pretty well.  The type of spline used is a
				natural spline calculated using a Lagrange polynomial.  This method was chosen because
				it only has n-1 unknowns, rather than a normal polynomial interpolation which has 4
				times as many unknowns.  It also allows a tridiagonal matrix to solve for all the
				unknowns, which is much faster than a normal matrix solving algorithm.

				Another addition to the project was the curses driver program.  This was done to make
				using the program a little more enjoyable and also to show some of the things that can
				be done with curses.  All in all these extra additions were an enjoyable challenge and I
				hope you enjoy them.

				See figure~\ref{fig:enlargecubic} and~\ref{fig:enlargestd} on
				page~\pageref{fig:enlargecubic} and~\pageref{fig:enlargestd}
				
				\begin{figure}[p] \centering \caption{difference image with noise}
					\includegraphics{images/subnoisy.png} \label{fig:subnoisy} \end{figure}
				
				\begin{figure}[p] \centering \caption{difference image without noise}
					\includegraphics{images/subclear.png} \label{fig:subclear} \end{figure}


\end{document}
