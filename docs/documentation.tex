\documentclass[pdftex, 11pt]{article}

\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{fullpage}
\usepackage{color}
\usepackage[pdftex,bookmarks=true,colorlinks=true,linkcolor=blue]{hyperref}

%this sets the line at the header
\setlength{\headheight}{15.2pt}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

% This is all for formatting and making the Table of Contents according to 
% spec. Don't play with it.
\makeatletter
\renewcommand\l@section[2]{%
  \ifnum \c@tocdepth >\z@
    \addpenalty\@secpenalty
    \addvspace{1.0em \@plus\p@}%
    \setlength\@tempdima{1.5em}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
      \leavevmode \bfseries
      \advance\leftskip\@tempdima
      \hskip -\leftskip
      #1\nobreak\ 
      \leaders\hbox{$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}
     \hfil \nobreak\hb@xt@\@pnumwidth{\hss #2}\par
    \endgroup
  \fi}
\makeatother



\begin{document}

%import the title page
\input{./title.tex}

%headers, footers, and table of contents
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection}}
\rhead{Page \thepage\ of \pageref{LastPage}}
\lhead{}
\lfoot{CS 302 | Spring 2010}
\cfoot{}
\renewcommand{\footrulewidth}{0.4pt}

\tableofcontents
\newpage

\lhead{Joshua Gleason \& Josiah Humphrey}
\rhead{Page \thepage\ of \pageref{LastPage}}
\rfoot{Section\ \rightmark}
\cfoot{}
\lfoot{CS 302 | Spring 2010}
\renewcommand{\footrulewidth}{0.4pt}

\section{Introduction}

In this assigment, the students were asked to make an image class that manipulated a Portable Gray Map (PGM) image
in various ways. This was to be accomplished using dynamic 2D arrays and other tools that were learned in previous CS courses.

One of the first problems faced was how to use the supplied read and write image files.
These functions were provided to simplefy the build process as they allowed the students to concentrate 
on the manipulation of the images.

After reading and writing images was mastered, the students undertook the bulk of the assignment which was to
manipulate the images that had been read in with the supplied read function. This required the knowledge of
manipulating dynamic 2D arrays. Dynamic 2D arrays was a new tool for the students' C++ repatoire, but the
students soon came to understand the benefits of dynamic 2D arrays.

The assignment also required the use of constructors, desctructors, copy contrusctors, and operator overloading,
These topics were review from CS 202, but the use of them refreshed the students minds on how they work
and to their purposes.

The students also extensively documented their program and made it as easy as possible to understand what
was happening in the various algorithms that were implemented. The students realize that commenting
and documenting the source code for projects is extremely important and is essential to the success of
a powerful programmer.

\section{Use of Code}

The use of the program should be very intuitive. The user must use the arrow keys to scroll in the menu and press enter
to select some option. The menu will then pop up windows and message boxes depending on the user's selection and the
user's input. This provides for a very effective setup and takes the burden out of trying to look at the keyboard and
the menu for key choices in a simple menu. Our menu uses ncurses to accomplish the scrolling menu. The students adapted
a ncurses API written by Micheal Leverington from CS 135 to implement a simple curses menu at the beginning, but after
all of the functions were completed, the students decided to make a more robust menu capable of scrolling. This was not
required, but was done for aesthetic reasons and for the experience that it allowed the students.

The image class that was implemented has all of the requirements for the functions. Each function is defined exactly
like Dr. Bebis wanted them to be defined and the coders adapted their coding style to match what Dr. Bebis expected. The
code is built fairly modular and most of the time expects the class user to bounds and error check before information is
sent to the class. There is some rudimentary error checking in the class itself, but it only prevents the most foul and
gross errors. The class is also setup to throw string objects in the case of an error. These thrown strings must be
caught in the driver, so it is up to the class user to implement the catches for these thrown strings. Strings were used
as the errors because of their ease of use and ease of manipulating them by the class user. 

The file IO functions that were provided by Dr. Bebis have been combined into a single file pair (.cpp and .h) called
imageIO. This allows a much more unified and modular approach to the use of the image IO features. It also makes
including the functions much easier to include into multiple source files.

Whenever a new image is needed by the user of the class, the user should always use the setImageInfo function that is
included in the image class. This function takes the rows, columns, and levels and creates a blank image to manipulate.
Another feature of this function is that it creates a checkered background of 25x25 squares that make it easy to see the
dimensions of the iamge if it is saved without modification. It is also helpful for functions that take an image and
move them somehow. For instance, if an image was translated by 55 pixels, the program user could see that there is 2.2
squares that are uncovered, showing that the images has been translated 55 pixels. This was a design choice that came
about as a result of how other image manipulation programs work and the students attempt at creating a robust iamge
manipulation rescource.

One last area that needs some mention to properly use is the function of operator+. This function includes a coefficient
that determines the weight that each image has when adding them together. The students mimiced Dr. Bebis name for this
coefficient and called it 'a'. When 'a' is large, the first image has more weight in the addition; when 'a' is small,
the second image has more weight, and when 'a' is .5, the images have equal weight in the addition. The coefficient can
be between 0 and 1.

\section{Functions}

\subsection{Image.h}
\begin{description}

	\item{\textsc{constructor}}
		\begin{description}
			\item{Purpose}

				default constructor allocates no memory and sets the size to zero 

			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				Sets everything to zero and 
				sets the pixelValue array to NULL


		\end{description}


	\item{\textsc{constructor with parameters}}
		\begin{description}
			\item{Purpose}

				change the dimenstions of the image, delete,
				and re-allocate memory if required

			\item{Input}

				An N, M, and Q value to set the new image to

			\item{Output}

				None

			\item{Assumptions}

				Sets the image to a certain size and intializes the
				image as a grid

		\end{description}



	\item{\textsc{desctructor}}
		\begin{description}
			\item{Purpose}

				Deletes and memory that has been dynamically allocated

			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				Checks to see if the pixelValue array has been set
				if so, deletes

		\end{description}


	\item{\textsc{copy\_constructor}}
		\begin{description}
			\item{Purpose}
		
				Creates a new array absed on the thing to be copied
				then sets the pixelValue of the new object the same as
				the old image

			\item{Input}

				ImageType rhs is the old image to be copied over into
				the new array


			\item{Output}

				None

			\item{Assumptions}

				The old image must be passed as reference to prevent
				an infinate loop


		\end{description}


	\item{\textsc{operator=}}
		\begin{description}
			\item{Purpose}

				equal operator overload, this is basically
				the same as the copy constructor
				except it will likely have to 
				de-allocate memory before copying values, all
				this is decided in setImageInfo however

			\item{Input}

				imageType rhs which is the old iamge to be 
				copied over to the new image

			\item{Output}

				Returns the imageType obejct so that
				equal chaining can be implemented


			\item{Assumptions}

				Assumes that the user is not trying to copy the same
				object into itself


		\end{description}


	\item{\textsc{getimageInfo}}
		\begin{description}
			\item{Purpose}
			
 				returns the width height and color depth 
				to reference variables

			\item{Input}

				\begin{itemize}
					\item{rows}

						This parameter grabs the number of rows
						in the imageType object

					\item{cols}

						This parameter grabs the number of cols
						in the imageType object

					\item{levels}

						This paremeter grabs the depth of the
						image in the imageType object

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes nothing but it makes sense that the object being
				queried has been loaded with some image



		\end{description}


	\item{\textsc{setImageInfo}}
		\begin{description}
			\item{Purpose}
			
				Sets the image info, deleting and allocating memory
				as required, also creates a background grid

			\item{Input}

				\begin{itemize}
					\item{rows}

						This parameter sets the number of rows
						in the imageType object

					\item{cols}

						This parameter sets the number of cols
						in the imageType object

					\item{levels}

						This paremeter sets the depth of the
						image in the imageType object

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes nothing

		\end{description}




	\item{\textsc{getpixelval}}
		\begin{description}
			\item{Purpose}

				Returns the value of a pixel

			\item{Input}

				\begin{itemize}

					\item{i}
					
						The row of the pixel

					\item{j} 

						The column of the pixel

				\end{itemize}

			\item{Output}

				The integer value of the pixel at 
				pixelValue[i][j]


			\item{Assumptions}

				It is assumed that the image has been intialized


		\end{description}


	\item{\textsc{setpixelval}}
		\begin{description}
			\item{Purpose}

				Sets the value of a pixel

			\item{Input}

				\begin{itemize}

					\item{i}

						The row of the pixel to be changed

					\item{j}

						The column of the pixel to be changed

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes the image has been intialized

		\end{description}


	\item{\textsc{getsubimage}}
		\begin{description}
			\item{Purpose}

 				Obtain a sub-image from old.  Uses the coordinates
				of the upper left corner
				and lower right corner to obtain image.

			\item{Input}

				\begin{itemize}

					\item{ULr}
	
						The upper left row of the pixel
						to be x in (0,0) in the new image.

					\item{ULc}

						The upper left column of the pixel
						to be y in (0,0) in the new image

					\item{LRr}

						The lower right row of the pixel
						to be x in (max\_x, max\_y) in the
						new image

					\item{LRC}

						The lower right row of the pixel
						to be y in (max\_x, max\_y) in the
						new image

				\end{itemize}


			\item{Output}

				None


			\item{Assumptions}

				Assumes that the UL\{r,c\} and LR\{r,c\} have been
				properly bounds and error checked before the function
				call

			\item{Example}

				\begin{figure}[h]
					\centering
					\caption{subImage Example}
					\includegraphics{images/outsubimg.png}
				\end{figure}

		\end{description}


	\item{\textsc{meangray}}
		\begin{description}
			\item{Purpose}

				
				this calculates the average gray value in the
				picture, this is done by adding
				all of the pixels and dividing by the total
				number of pixels

			\item{Input}

				None

			\item{Output}

				A double value that is the mean value of all
				the pixels in pixelValue


			\item{Assumptions}

				Assumes nothing and returns 0 if the image 
				has not been intialized

		\end{description}


	\item{\textsc{enlargeImage}}
		\begin{description}
			\item{Purpose}
				
				This function enlarges an image by a 
				magnitude of s, so for example if the
				original function was 100x100 and s is 
				10, then the new image is 1000x1000

			\item{Input}

				\begin{itemize}

					\item{S}

						This is the magnitude of the enlargement

						The function is also overloaded 
						to accept ints as well as doubles

					\item{ImageType old}

						This is the image to be enlarged

					\item{cubic}

						A bool value that decides which type of
						interpolation to use.
						If true, use cubic interpolation
						If false, use linear interpolation
				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}


				The method choosen to use was bicubic/linear
				interpolation which creates
				splines for each column(cubic or linear),
				then using those splines create an
				image which is a stretched version of the original 
				image.  The way this was achieved
				was to stretch the entire image only vertically,
				and then stretch that
				image horizontally.  Then the same thing was done except
				reversed (stretched image
				horizontally first) and then the two image summed 
				together.  This gives an
				average value between both methods.  Although it can
				handle S values less
				than 1, the shrinkImage function works better for this.

		\end{description}

	\item{\textsc{shrinkImage}}
		\begin{description}
			\item{Purpose}

				Shrink image, average all the values
				in the block to make the new pixel, this
				makes the shrink much less jagged looking in the end

			\item{Input}

				\begin{itemize}

					\item{s}

						The inteter value of the shrink factor

					\item{ImageType old}

						The image to be shrunk

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes the image has been intialized and that error
				checking has been done.

			\item{Example}

				\begin{figure}[h]
					\centering
					\caption{shrinkImage Example}
				\includegraphics{images/outshrink.png}
			\end{figure}

		\end{description}


	\item{\textsc{reflectImage}}
		\begin{description}
			\item{Purpose}

				reflects image by moving the pixel to N or M
				minus the current row or column
				depending on the value of the flag
				(true being a horizontal reflection and
				false being a vertical reflection)

			\item{Input}

				\begin{itemize}

					\item{flag}

						The flag that sets either vertical or
						horizontal reflection

					\item{ImageType old}

						The image to be reflected

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes nothing, but it makes sense to have an intialized
				image to reflect

			\item{Example}

				\begin{figure}[h]
					\centering
					\caption{reflectImage Example}
				\includegraphics{images/outreflect.png}
			\end{figure}

		\end{description}


	\item{\textsc{translateImage}}
		\begin{description}
			\item{Purpose}

				Translate the image down to the right,
				any part that goes out of the screen is
 				not calculated.  Checkered background from
				setImageInfo is retained.

			\item{Input}

				\begin{itemize}

					\item{t}

						The integer value of the translation. The
						translation will occur down and 
						to the right 't' pixels

					\item{ImageType old}

						The image to be translated

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				No assumptions are made, but it makes sense to have
				an intialized image

			\item{Example}

				\begin{figure}[h]
					\centering
					\caption{translateImage Example}
				\includegraphics{images/outtrans.png}
			\end{figure}

		\end{description}


	\item{\textsc{rotateImage}}
		\begin{description}
			\item{Purpose}

				Rotate the image clockwise using bilinear
				interpolation, basically traversing
				the entire image going from the destination 
				to the source by using the
				in reverse (which is why its clockwise). 
				Once a location is determined the
				surrounding pixels are used to calculate 
				intermediate values between the
				pixels, this gives a pretty smooth rotate.

			\item{Input}

				\begin{itemize}

					\item{theta}

						The degrees to rotate. This is converted
						to radians inside the function

					\item{ImnageType old}

						The image to be rotated

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes that theta is in degrees because theta is
				converted to radians from degrees inside the function
				for the use of the trig functions.
				It is also assumed that the image has been intialized
				before the function call. It is also assumed that theta
				is between 0 and 360.

			\item{Example}

				\begin{figure}[h]
					\centering
					\caption{rotateImage Example}
				\includegraphics{images/outrotate.png}
			\end{figure}

		\end{description}


	\item{\textsc{operator+}}
		\begin{description}
			\item{Purpose}

				
				Sum two images together, basically just finding
				the average pixel value of
				every pixel between two images.  Throws an
				exception if dimesions of both
				images don't match

			\item{Input}

				\begin{itemize}
						
					\item{ImageType rhs}

						This is the image to be added to
						'this' image

				\end{itemize}

			\item{Output}

				ImageType object to chain additions

			\item{Assumptions}

				It is assumed that each image have the same dimensions.
				However, if the images do not have the same dimensions,
				then a string is thrown stating that the images do
				not have the same dimensions. It is not neccesary to have
				each image initialized, but it makes senses
				that they would each be initialized.

			\item{Example}

				\begin{figure}[h]
					\centering
					\caption{operator+ Example}
				\includegraphics{images/outasum.png}
			\end{figure}


		\end{description}


	\item{\textsc{operator-}}
		\begin{description}
			\item{Purpose}

				subtract two images from each other to see the 
				differences, if the magnitude of
				the difference is less then Q/6 then the pixel
				is replaced with black,	otherwise white is used. 
				This seems to help reduce 
				the amount of noise in the pictures

			\item{Input}

				\begin{itemize}

					\item{ImageType rhs}

						This is the image to be subtracted from
						'this' image

				\end{itemize}

			\item{Output}

				ImageType is returned to allow chaining of subtraction

			\item{Assumptions}

				It is assumed that each image have the same dimensions.
				However, if the images do not have the same dimensions,
				then a string is thrown stating that the images do
				not have the same dimensions. It is not neccesary to have
				each image initialized, but it makes senses
				that they would each be initialized.

			\item{Example}

				\begin{figure}[h]
					\centering
					\caption{operator- Example}
				\includegraphics{images/outsubtract.png}
			\end{figure}

		\end{description}


	\item{\textsc{negateImage}}
		\begin{description}
			\item{Purpose}

				This function simply subtracts the current pixel
				value from the max value of
				the pixel, thus negating the image

			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				Nothing is assumed

			\item{Example}

				\begin{figure}[h]
					\centering
					\caption{negateImage Example}
				\includegraphics{images/outnegative.png}
			\end{figure}

		\end{description}


\end{description}

\subsection{driver.cpp}

\begin{description}

	\item{\textsc{showmenu}}

		\begin{description}
			\item{Purpose}
				
 				This is the function which builds the scrolling menu system, this simply
				creates a curses window and puts all the options stored in menuStr onto the
				window, it then waits for the user to press UP, DOWN, or RETURN before
				reacting.  The parameters allow menus to be different widths, heights, and
				locations.  A few constants can be changed to change the colors of the window.

			\item{Input}
				
				\begin{itemize}

					\item{*\&menu}

						An un-initialized window pointer.

					\item{title[]}

						A string to be the title.

					\item{height and width}

						The height and width of the menu.

					\item{locY and locX}
						
						The y and x locations of the menu's upper left corner.

					\item{menuStr[][NAME\_LEN] }

						A list of c-style strings to be used in the menu.
						
					\item{choices}
					
						The number of strings in menuStr.

					\item{erase}
						
						A bool value which says if the last choice is left highlighted.
						Default value is true.

				\end{itemize}

			\item{Output}
				
				Display a window with menu options, let user choose and
				return the index of that choice.

			\item{Assumptions}

				Assumes that window is un-intialized and will be destructed
				by calling function.

		\end{description}


	\item{\textsc{showregs}}

		\begin{description}
			\item{Purpose}

 				Display a window of registers next to the main menu (or wherever the constants
				dictate).

			\item{Input}
			
				\begin{itemize}

					\item{*\&regWin}
						
						An un-initialized window pointer.

					\item{loaded[]}

						A list of bools representing which registers are loaded.

					\item{names[][NAMES\_LEN]}

						A list of the names of each register.

				\end{itemize}

			\item{Output}

				Displays a window next to main of all the registers.

			\item{Assumptions}

				This allocates memeory for a WINDOW but it doesn't delete it.

		\end{description}


	\item{\textsc{drawwindow}}

		\begin{description}
			\item{Purpose}

				This function simply draws an empty window with a given title, height, width,
				x, and y locations.  The colors have default values but can be changed if
				oddly colored windows are wanted.

			\item{Input}

				\begin{itemize}

					\item{*\&win}

						An un-initialized window pointer.

					\item{title[]}

						A c-style string.

					\item{height and width}

						The height and width of the desired window.

					\item{y and x}

						The y and x locations of the upper left corner.

					\item{bgColor and fgColor}

						The background and foreground colors, both have default values equal
						to the menu colors defined as constants.

				\end{itemize}

			\item{Output}

				Displays a empty window with a border and title using the
				given parameters.

			\item{Assumptions}

				This allocates memeory for a WINDOW but it doesn't delete it.

		\end{description}


	\item{\textsc{deletemenu}}

		\begin{description}
			\item{Purpose}

				This basically clears the entire screen after deleting the window that is
				passed.

			\item{Input}

				\begin{itemize}

					\item{*\&menu}

						A window pointer which has been initialized.	

				\end{itemize}

			\item{Output}

				De-allocate memory for the window pointer and refresh the
				main screen.

			\item{Assumptions}

				Assumes WINDOW object is intialized before calling.


		\end{description}


	\item{\textsc{processentry}}
		\begin{description}
			\item{Purpose}

				This is the function that decides where to go depending on the choice in the
				main menu.  The reason it has all the parameters is for passing to the
				subsequent functions that will be using them.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of images that are stored in the registers.

					\item{loaded[]}

						A list of bools that represent if each register is loaded.

					\item{name[][NAME\_LEN]}

						The names of all the registers as c strings.

					\item{choice}
				
						The choice the user made at the main menu.

				\end{itemize}

			\item{Output}

				Depending on the value of choice, call a function to do some image
				manipulation.

			\item{Assumptions}

				Assumes value $\geq$ 0 and $<$ MENU\_OPTIONS, not that anything
				will crash if its not true, but nothing will happen, also
				assumes that names contain valid c strings.

		\end{description}



	\item{\textsc{stdwindow}}
		\begin{description}
			\item{Purpose}

				This just builds the window used for message box, this function is just to
				simplify the plethora of other functions that use this.
				
			\item{Input}
				
				\begin{itemize}

					\item{newWin}

						An un-initalized window pointer.

					\item{title[]}

						A c style string.

				\end{itemize}

			\item{Output}

				Displays a window in the standard text box location with
				the title and a border.

			\item{Assumptions}

				The window object is initalized here but not deleted, this
				is left up to the calling function.

		\end{description}



	\item{\textsc{promptforreg}}
		\begin{description}
			\item{Purpose}
				
				This is the function that calls the menu for the register prompt, it can be
				called in different locations (like in addImg and subImg) but has a default
				defined by some global constants.  The function creates a list of registers
				and adds the "Back" option as the final option, this way the user has the
				option to cancel choosing a register.  Although in the program it looks like
				the register display and register choosing window are the same, this menu
				overlaps the other menu to make it seem like control is transfering to another
				window.

			\item{Input}

				\begin{itemize}

					\item{loaded[]}

						A list of flags indicating which registers are loaded.

					\item{name[][NAME\_LEN]}

						A list of names of each register.

					\item{check}

						A flag used to indicate weather registers that aren't loaded are valid.

					\item{y and x}

						The y and x locations of the menu, default values are defined for this.

				\end{itemize}

			\item{Output}
				
				Display a menu with the registers in it, allowing user to
				choose a register.

			\item{Assumptions}

				Assumes that names are already set to valid c strings.

		\end{description}



	\item{\textsc{promptforfilename}}
		\begin{description}
			\item{Purpose}

				Create a message box and prompt the user for a string value with given prompt.

			\item{Input}

				\begin{itemize}

					\item{title[]}

						The title of the prompt window as a c style string.

					\item{prompt[]}

						The prompting message.

					\item{str[]}

						A string in which to store output into.

				\end{itemize}

			\item{Output}

				Sets the final parameter equal to the filename the user
				chooses and returns the length.

			\item{Assumptions}

				Assumes first 2 parameters are valid c strings and that
				the final parameter is a string of at least length 16 plus
				the length of the file path declared as a constant.

		\end{description}



	\item{\textsc{promptforloc}}
		\begin{description}
			\item{Purpose}

				This function prompts the user for a location (both row and column) and sets
				the valid points equal to row or col.  If -1 is returned in either location
				it means user choose to cancel the prompt.  The validity of the points is
				calculated by the image object it is passed.  The image properties are
				calculated and then used to determine the bounds of row and column.

			\item{Input}

				\begin{itemize}

					\item{title[]}

						The title of the prompt window as a c style string.

					\item{\&img}

						This is just so the dimensions of the image can be obtained.

					\item{\&row and \&col}

						Used to store the user's input values.

				\end{itemize}

			\item{Output}

				Sets two reference parameters equal to row and column of
				users choice.

			\item{Assumptions}

				Assumes image is intialized and has a valid height and width
				also that first parameter is a valid c string.

		\end{description}



	\item{\textsc{promptforpixvalue}}
		\begin{description}
			\item{Purpose}

				Prompt for a pixel value which is from 0 to maxVal, if not display message
				box and re-prompt user until valid choice is made.

			\item{Input}

				\begin{itemize}
					
					\item{title[]}

						The title of the prompt window as a c style string.

					\item{prompt[]}

						The prompting message.

					\item{maxVal}

						The maximum value allowed to input.

				\end{itemize}

			\item{Output}

				Prompts user in message window and returns the value when
				the user inputs a valid value(-1 indicates cancel).

			\item{Assumptions}

				Assumes that first 2 parameters are valid c strings.

		\end{description}



	\item{\textsc{promptforscalevalue}}

		\begin{description}
			\item{Purpose}

				This function prompts the user for a scale value and checks to make sure it
				is not greater than maxVal and not less than 2.  This is used in the enlarge
				and shrink functions.

			\item{Input}

				\begin{itemize}
					
					\item{title[]}

						The title of the prompt window as a c style string.

					\item{prompt[]}

						The prompting message.

					\item{maxVal}

						The maximum value allowed to input.

				\end{itemize}

			\item{Output}

				Prompts user in message window and returns the value when
				the user inputs a valid value(-1 indicates cancel).

			\item{Assumptions}

				Assumes that first 2 parameters are valid c strings.

		\end{description}


	\item{\textsc{promptformirrow}}

		\begin{description}
			\item{Purpose}

				Prompt the user for the characters h, v, or c (not case sensitive) and return
				the value as soon as one of the 3 is pressed.

			\item{Input}

				\begin{itemize}
					
					\item{title[]}

						The title of the prompt window as a c style string.

					\item{prompt[]}

						The prompting message.

				\end{itemize}

			\item{Output}

				Returns users choice as a char.

			\item{Assumptions}

				Both parameters are valid c strings.

		\end{description}


	\item{\textsc{promptforangle}}

		\begin{description}
			\item{Purpose}

				Prompt user for a valid angle using a message box, make sure input is between
				0 and 360, if not display a message box and then re-prompt.

			\item{Input}

				\begin{itemize}
					
					\item{title[]}

						The title of the prompt window as a c style string.

					\item{prompt[]}

						The prompting message.

				\end{itemize}

			\item{Output}

				Returns the user angle choice.

			\item{Assumptions}

				Both parameters are valid c strings.

		\end{description}


	\item{\textsc{messagebox}}
		\begin{description}
			\item{Purpose}

				Displays a message box in the center of the screen with
				the message displayed in it.

			\item{Input}

				\begin{itemize}
					
					\item{title[]}

						The title of the window as a c style string.

					\item{msg[]}

						The message to be displayed in the message box.

				\end{itemize}


			\item{Output}
				
				Displays a message box in the center of the screen with
				the message displayed in it, then waits for the user to press
				return before continuing.

			\item{Assumptions}

				Assumes both parameters are valid c strings.

		\end{description}



	\item{\textsc{fillregs}}
		\begin{description}
			\item{Purpose}

				This displays a simple message box to the screen with the given title and msg
				inside of it, it waits for the user to press RETURN before returning to
				calling function.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.
					
					\item{argc}

						The number of strings in argv.

					\item{**argv}

						The parameters passed to main.

				\end{itemize}

			\item{Output}

				Sets valid arguments to registers (loading images) and
				clears the rest of the registers.

			\item{Assumptions}

				Assumes that char** is a valid list of strings with int
				rows.

		\end{description}



	\item{\textsc{clearregisters}}
		\begin{description}
			\item{Purpose}

				Prompt for a register that is filled and then clear it.
				
			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{loadimage}}
		\begin{description}
			\item{Purpose}

				Prompt the user for a register to load to, then let them choose from a list
				of the .pgm files in the local images directory (defined as a constant).

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{saveimage}}
		\begin{description}
			\item{Purpose}

				Save image from a register to the local images directory, prompting user for
				register and file name.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{getimageinfo}}
		\begin{description}
			\item{Purpose}

				Simply retrieve image information and display to a window below the registers
				The data being displayed is the Register number, Image Height, Width, Q value,
				and average gray value.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{setpixel}}
		\begin{description}
			\item{Purpose}

				Prompt user for a register then a pixel location (row, col) and then the pixel
				value to change that pixel to.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{getpixel}}
		\begin{description}
			\item{Purpose}

				Return the value of a pixel in a selected image to the user.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{extractsub}}
		\begin{description}
			\item{Purpose}

				After getting the image to manipulate, prompt for two corners to make a
				subimage out of, if the lower right corner is above or left of the upper
				right corner re-prompt for valid points

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{enlargeimg}}
		\begin{description}
			\item{Purpose}

				This function prompts the user for a scale value to enlarge an image by, it
				makes sure the scale value does not make the image larger than MAX\_IMG value
				because it may cause a stack overflow.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{shrinkimg}}
		\begin{description}
			\item{Purpose}

				The same as enlarge except it shrinks the image making sure it never gets
				smaller than MIN\_IMG.  This is because some image viewers won't open images
				as small as 2x2 (xv for example).

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{reflectimg}}
		\begin{description}
			\item{Purpose}

				Prompt user for a direction to reflect an image then reflect the image and
				store it back in the original register image.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{translateimg}}
		\begin{description}
			\item{Purpose}
			
				This prompts the user for how far to translate the image, then calls the
				translate function which moves the image down to the right 't' number of
				pixels.  Also Won't let user choose t value that would move image totaly off
				the screen.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{rotateimg}}
		\begin{description}
			\item{Purpose}

				This prompts the user for an angle theta which will rotate the image counter 
				clockwise by theta degrees.  The input is only valid from 0 to 360 which
				should cover all possibilities.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{sumimg}}
		\begin{description}
			\item{Purpose}

				Prompt for 2 images and attempt to sum them, there is no size checking because
				operator+ will throw a string which will be handeled by main if sizes of the
				two images are different.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{subtractimg}}
		\begin{description}
			\item{Purpose}

				Prompt for 2 images and attempt to calculate the difference, there's no size
				checking here for the same reason sumImg doesn't do size checking

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{negateimg}}
		\begin{description}
			\item{Purpose}

				Prompt user for which image to negate and negate it, pretty simple function.

			\item{Input}

				\begin{itemize}

					\item{img[]}

						A list of all the images stored in the registers.

					\item{loaded[]}

						A list of bools representing if each register is loaded.

					\item{name[][NAME\_LEN]}

						A list of names of every register.

				\end{itemize}

			\item{Output}

				Prompt the user for which register to use, then if nessessary
				prompt for additional information and call the function
				in ImageType that will allow the image in that register to
				be manipulated.

			\item{Assumptions}

				Assumes all names in the c string list are valid c
				strings and the bools coincide with the image types that
				reference the same index.

		\end{description}



	\item{\textsc{findlocalpgm}}
		\begin{description}
			\item{Purpose}

				A somewhat brittle function that reads all the .pgm files from a local
				directory (defined as a constant) and places them into a dynamically
				allocated c style string array.

			\item{Input}

				\begin{itemize}

					\item{**filenames}
						
						A double char pointer that is uninitialized.

				\end{itemize}

			\item{Output}

				Allocates enough memory for a list of all the ".pgm" files
				in the local path specified by the FILELOC constant.  It
				then copys the file names to the array and returns the
				number of rows in the array.

			\item{Assumptions}

				Pointer parameter is not initialized, but will be in the function
				this means it needs to be de-allocated later.

		\end{description}


\end{description}

\subsection{cubicspline.h}

\begin{description}
	\item{\textsc{constructor}}
		\begin{description}
			\item{Purpose}

				Initialize everything to NULL and 0.

			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				After this runs, all variables are zero.

		\end{description}


	\item{\textsc{constructor with parameters}}
		\begin{description}
			\item{Purpose}

				Let object be initialized and create a linear and cubic spline based
				on the parameters.

			\item{Input}

				\begin{itemize}

					\item{points[]}

						The array of points to be interpolated.

					\item{num}

						The number of points in the array.

				\end{itemize}

			\item{Output}
			
				Sets the variables for both cubic and linear splines in the object.

			\item{Assumptions}

				It is assumed that there are at least 3 points, otherwise cubic splines can't
				be created with this algorithm.

		\end{description}


	\item{\textsc{destructor}}
		\begin{description}
			\item{Purpose}

				Delete all dynamically allocated memory before object is removed.

			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				None

		\end{description}


	\item{\textsc{create}}
		\begin{description}
			\item{Purpose}

				Using the points make it possible to calculate a location along the
				piecewise function at a later time.  Creates a linear spline function.

			\item{Input}

				\begin{itemize}

					\item{points[]}

						A list of points to be used to interpolate.

					\item{num}

						The number of points.

				\end{itemize}

			\item{Output}

				Sets the object up so that linear approximations of intermediate values between
				the points can be obtained using the getVal() function.

			\item{Assumptions}

				There is at least 1 point.

		\end{description}


	\item{\textsc{createcubic}}
		\begin{description}
			\item{Purpose}

				Using the points make it possible to calculate a location along the
				piecewise function at a later time.  Creates a cubic spline function.

			\item{Input}
			
				\begin{itemize}

					\item{points[]}

						A list of points to be used to interpolate.

					\item{num}

						The number of points.

				\end{itemize}

			\item{Output}

				Sets the object up so that cubic approximations of intermediate values between
				the points can be obtained using the getCubicVal() function.

			\item{Assumptions}

				It is assumed that 3 or more points exist.

		\end{description}


	\item{\textsc{getval}}
		\begin{description}
			\item{Purpose}

				Returns an estimated value along the function, the spline function assumes
				that the first point lies at 0.0 and the final point lies at 100.0 with each
				point equally spaced.  Uses a linear spline.

			\item{Input}

				\begin{itemize}

					\item{x}

						A floating point value of the desired location along the function.

				\end{itemize}

			\item{Output}

				Returns the value of the intermediate approximation between the points.

			\item{Assumptions}

				Assumes a linear spline has been defined. a.k.a. the function create()
				has been called, initializing the spline.

		\end{description}


	\item{\textsc{getcubicval}}
		\begin{description}
			\item{Purpose}

				Returns an estimated value along the function, the spline function assumes
				that the first point lies at 0.0 and the final point lies at 100.0 with each
				point equally spaced.  Uses a cubic spline.

			\item{Input}

				\begin{itemize}

					\item{x}

						A floating point value of the desired location along the function.

				\end{itemize}

			\item{Output}

				Returns the value of the intermediate approximation between the points.

			\item{Assumptions}

				Assumes a cubic spline has been defined. a.k.a. the function createCubic() has
				been called, initializing the spline.

		\end{description}


\end{description}

\subsection{imageIO.h}

\begin{description}
	\item{\textsc{readimageheader}}
		\begin{description}
			\item{Purpose}

				Reads the iamge header amd puts them into values that
				are passed by reference

			\item{Input}

				\begin{itemize}

					\item{fname[]}

						This is the name of the file stored
						as a C-style string

					\item{N}

						This is the number of rows in the image

					\item{M}

						This is the number of columns in
						the image

					\item{Q}

						This is the depth of the image

					\item{type}

						This makes sure that the file type is
						.pgm and not some other format
						
				\end{itemize}
						
						
			\item{Output}

				None

			\item{Assumptions}

				Assumes that a file exists and is in pgm format

		\end{description}


	\item{\textsc{readimage}}
		\begin{description}
			\item{Purpose}

				Reads the image into the image object from a file

			\item{Input}

				\begin{itemize}

					\item{fname[]}

						The C-style string to hold the image 
						file name

					\item{ImageType image}

						The image object that holds the
						image data

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				Assumes there is a file to be read and that the
				user has read access

		\end{description}


	\item{\textsc{writeimage}}
		\begin{description}
			\item{Purpose}

				Writes the image to disk

			\item{Input}

				\begin{itemize}

					\item{fname[]}

						The C-style string to hold the image 
						file name

					\item{ImageType image}

						The image object that holds the
						image data

				\end{itemize}



			\item{Output}

				None

			\item{Assumptions}

				Assumes the user has write access to the
				destination folder

		\end{description}


\end{description}

\subsection{comp\_curses.h}
\begin{description}

	\item{\textsc{startcurses}}
		\begin{description}
			\item{Purpose}

				This initializes the curses screen and its functions

			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				No assumptions are made besides have a terminal
				capable of displaying curses correctly.

		\end{description}


	\item{\textsc{endcurses}}
		\begin{description}
			\item{Purpose}

				This ends the curses screen and its functions

			\item{Input}

				None

			\item{Output}

				None

			\item{Assumptions}

				This assumes that curses has ibeen initialized
				with startCurses()


		\end{description}


	\item{\textsc{setcolor}}
		\begin{description}
			\item{Purpose}

				This sets the colors for stdscr

			\item{Input}

				\begin{itemize}

					\item{*somewin}

						This is the window pointer to set
						the colors to a specific window

					\item{cf}

						This is the first color (foreground)
						for the color pair to set in the window

					\item{cb}

						This is the second colod (background)
						for the color pair to set in the window
						
				\end{itemize}	

			\item{Output}

				None

			\item{Assumptions}

				Assumes that screen has been initialized

		\end{description}


	\item{\textsc{screenwidth}}
		\begin{description}
			\item{Purpose}

				Returns the max screen x value 

			\item{Input}

				None

			\item{Output}

				The int value of the max x value for the entire terminal

			\item{Assumptions}

				Assumes startCurses() has been run

		\end{description}


	\item{\textsc{screenheigth}}
		\begin{description}
			\item{Purpose}

				Returns the max screen y value

			\item{Input}

				None

			\item{Output}

				The int value of the max y value for the entire terminal

			\item{Assumptions}

				Assumes startCurses() has been run

		\end{description}


	\item{\textsc{promptforint}}
		\begin{description}
			\item{Purpose}

				Prompts for an int at some int at some (x,y) cordinate

			\item{Input}

				\begin{itemize}

					\item{*somewin}

						Some window to prompt for the int in

					\item{y}

						The y cordinate at which to prompt
						for the int

					\item{x} 

						The x cordinate at which to prompt
						for the int

					\item{promptString[]}

						The string to display when prompting for
						the int
						
				\end{itemize}

			\item{Output}

				The integer value of the user's input

			\item{Assumptions}

				It is assumed that startCurses() has been run.
				The function has built in error checking to prevent
				bad data from being input

		\end{description}


	\item{\textsc{promptfordouble}}
		\begin{description}
			\item{Purpose}

				Prompts for a double at some int at some (x,y) cordinate

			\item{Input}

				\begin{itemize}

					\item{*somewin}

						Some window to prompt for the double in

					\item{y}

						The y cordinate at which to prompt
						for the double

					\item{x} 

						The x cordinate at which to prompt
						for the double

					\item{promptString[]}

						The string to display when prompting for
						the double
						
				\end{itemize}



			\item{Output}

				The double value of the user's input

			\item{Assumptions}

				It is assumed that startCurses() has been run.
				The function has built in error checking to prevent
				bad data from being input (such as multiple periods)

		\end{description}


	\item{\textsc{promptforstring}}
		\begin{description}
			\item{Purpose}

				Prompts for a string at some (x,y) cordinate

			\item{Input}

				\begin{itemize}

					\item{*somewin}

						The window at which to prompt
						for the string

					\item{y}

						The y cordinate at which to prompt

					\item{x}

						The rxy cordinate at which to prompt

					\item{promptstring}

						The string to display when prompting
						for the string

					\item{str[]}

						The array for the string that is typed
						in by the user

					\item{len}

						The length of the string stored

				\end{itemize}

			\item{Output}

				None

			\item{Assumptions}

				It is assumed that startCurses() has been run.
				The function also accounts for backspaces and
				makes sure that only valid input is entered.

		\end{description}


\end{description}

\section{Bugs and Errors}

hmm what goes here

\section{What was Learned}

The most important thing learned in this assigment was the use of dynamic 2D arrays. This was not taught in the previous
semester of CS, so the concept of it was new to the students. This challenge did not sway them though. the students
quickly grasped the concepts of a dynamic 2D array and easily implemented it into the image class. The students were
then able to design the functions that manipulated the 2D array that in turn manipulated the image. This was an
important concept to grasp because without understanding the concepts of a 2D array, the students would not be able to
correctly develop algorithms that correctly manipulated the image. 

Another concept that the students learned was the knowledge of how images are stored. The students had first hand
experience with an image format and this knowledge allowed the students to have a greater understanding of how computers
and the data structures associated with file formats intertwine with the software developer. The students have more of
an appreciation for the neccesity of data structures and the implications of designing easy to use and compact data
structures for the end user. 

One of the other concepts that the students learned was the ability to use ncurses in their program. This knowledge
allowed the students to create a very easy-to-use menu that is capable of multiple floating and scrollable menus. While
this part of the program was not needed, the students had a desire to learn more about C++ than what is being taught in
the class and brought it upon themselves to learn about ncurses. This knowledge has greatly improved their knowledge of
pointers and correct program structure because ncurses utilizes many pointers. The implementation of ncurses also becomes
very complex if there is not a clean program structure implemented. There are many facets of ncruses that are
intertwined, so the students made a clean and modular ncurses driver that is able to be easily read.

\section{Division of Labor}



\end{document}
