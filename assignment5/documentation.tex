\documentclass[pdftex, 12pt]{article}

\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{fullpage}
\usepackage{color}
\usepackage{amsmath}
\usepackage[pdftex,bookmarks=true,colorlinks=true,linkcolor=blue]{hyperref}
\usepackage{subfig}

%this sets the line at the header
\setlength{\headheight}{15.2pt}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

% This is all for formatting and making the Table of Contents according to 
% spec. Don't play with it.
\makeatletter
\renewcommand\l@section[2]{%
  \ifnum \c@tocdepth >\z@
    \addpenalty\@secpenalty
    \addvspace{1.0em \@plus\p@}%
    \setlength\@tempdima{1.5em}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
      \leavevmode \bfseries
      \advance\leftskip\@tempdima
      \hskip -\leftskip
      #1\nobreak\ 
      \leaders\hbox{$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}
     \hfil \nobreak\hb@xt@\@pnumwidth{\hss #2}\par
    \endgroup
  \fi}
\makeatother



\begin{document}

%import the title page
\input{./title.tex}

%headers, footers, and table of contents
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection}}
\rhead{Page \thepage\ of \pageref{LastPage}}
\lhead{}
\lfoot{CS 302 | Spring 2010}
\cfoot{}
\renewcommand{\footrulewidth}{0.4pt}

\tableofcontents

%\listoffigures
\newpage

\lhead{Joshua Gleason \& Josiah Humphrey}
\rhead{Page \thepage\ of \pageref{LastPage}}
\rfoot{Section\ \rightmark}
\cfoot{}
\lfoot{CS 302 | Spring 2010}
\renewcommand{\footrulewidth}{0.4pt}

\section{Introduction}

\section{Use of Code}

\section{Functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%       PART 1      %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{binaryTree.h}
\begin{description}

	\item{\textsc{binaryTree}}
		\begin{lstlisting}
			binaryTree();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Constructor, simply initializes root to NULL

			\item{Input}

				N/A

			\item{Output}

				N/A

			\item{Assumptions}

				N/A

		\end{description}
	\item{\textsc{~binaryTree}}
		\begin{lstlisting}
			~binaryTree();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Free all the memory in the tree

			\item{Input}

				N/A

			\item{Output}

				N/A

			\item{Assumptions}

				N/A

		\end{description}
	\item{\textsc{makeEmpty}}
		\begin{lstlisting}
			void makeEmpty();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}
				
				Recursively remove all the nodes below the node.
			
			\item{Input}
			
				A node.

			\item{Output}

				N/A

			\item{Assumptions}

				Node is either NULL or points to an allocated node type.

		\end{description}
	\item{\textsc{isEmpty}}
		\begin{lstlisting}
			bool isEmpty() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Test if tree is empty.

			\item{Input}

				N/A

			\item{Output}

				Returns true if tree is empty, otherwise returns false.

			\item{Assumptions}

				N/A

		\end{description}
	\item{\textsc{numberOfNodes}}
		\begin{lstlisting}
			int numberOfNodes() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Count the number of nodes in the tree recursively.

			\item{Input}

				N/A

			\item{Output}

				Return the number of nodes in the tree.

			\item{Assumptions}

				N/A

		\end{description}
	\item{\textsc{retrieveItem}}
		\begin{lstlisting}
			bool retrieveItem(iType&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Attempts to retrieve an item from the tree, return false if item is not found in the tree.

			\item{Input}

				An item that has the same "key" value as the item in question.

			\item{Output}

				Return true if item is in tree, false otherwise.

			\item{Assumptions}

				N/A

		\end{description}
	\item{\textsc{insertItem}}
		\begin{lstlisting}
			void insertItem(iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Create a new node and insert it into the tree with the value of the parameter.

			\item{Input}

				The value to be placed in the tree.

			\item{Output}

				N/A

			\item{Assumptions}

				N/A

		\end{description}
	\item{\textsc{deleteItem}}
		\begin{lstlisting}
			void deleteItem(iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Remove a node from the tree.

			\item{Input}

				An item with the same key value as the item to be removed.

			\item{Output}

				N/A

			\item{Assumptions}

				The value of the item must exist in the tree, use retrieveItem to test before calling this unless it is
				certain that the item is in the tree.

		\end{description}
	\item{\textsc{resetTree}}
		\begin{lstlisting}
			void resetTree(oType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Generate a queue to traverse the tree in a particular order.

			\item{Input}

				An order type which can be IN\_ORDER, PRE\_ORDER, or POST\_ORDER, each one initializes a different
				queue.

			\item{Output}

				N/A

			\item{Assumptions}

				N/A

		\end{description}
	\item{\textsc{getNextItem}}
		\begin{lstlisting}
			bool getNextItem(iType&, oType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Retrieve the next item in the queue corresponding to the value of oType.

			\item{Input}

				A reference parameter used to store the retrieved data and an order type of which queue to retrieve
				from.

			\item{Output}

				Return true if the item is the last item in the queue, also make the reference parameter equal to the
				value of the next item in the queue.

			\item{Assumptions}

				Assumes the proper queue as been initialized and is not empty.  Use the resetTree and isEmpty functions
				to ensure this is the case.

		\end{description}
	\item{\textsc{printTree}}
		\begin{lstlisting}
			void printTree(ostream&) const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Prints the tree to the desired ostream type.

			\item{Input}

				An ostream object by reference, this could be cout or an ofstream.

			\item{Output}

				Outputs all values of the tree to the desired ostream.

			\item{Assumptions}

				Assumes that the left shift opperator << has been overloaded for ostream to output the iType values
				properly.

		\end{description}
	\item{\textsc{countNodes}}
		\begin{lstlisting}
			int countNodes(treeNode<iType>*);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				The client function called by numberOfNodes that does the recursive counting.

			\item{Input}

				A node pointer.

			\item{Output}

				Recursively determines the number of nodes connected to the parameter node plus 1.

			\item{Assumptions}

				Assumes parameter points to valid node or is NULL.

		\end{description}
	\item{\textsc{retrieve}}
		\begin{lstlisting}
			bool retrieve(treeNode<iType>*, iType&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				The recursive component to retrieveItem.

			\item{Input}

				A node pointer and the item in question.

			\item{Output}

				Returns true if item is found, false if it is not.

			\item{Assumptions}

				Assumes parameter points to valid node or is NULL.

		\end{description}
	\item{\textsc{insert}}
		\begin{lstlisting}
			void insert(treeNode<iType>*&, iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				The recursive component to insertItem, recursively traverses the tree to find the appropriate place to
				put the node.

			\item{Input}

				A node pointer and the item to be inserted.
				
			\item{Output}

				N/A

			\item{Assumptions}

				Assumes the pointer points to a valid node or is NULL.

		\end{description}
	\item{\textsc{deleteOut}}
		\begin{lstlisting}
			void deleteOut(treeNode<iType>*&, iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				This portion of the function finds the correct node to be deleted recursively, then calls deleteNode to
				actually do the delete.

			\item{Input}

				A node pointer and the item to be deleted.

			\item{Output}

				N/A

			\item{Assumptions}

				Assumes the value held by the iType parameter exists in the tree.

		\end{description}
	\item{\textsc{deleteNode}}
		\begin{lstlisting}
			void deleteNode(treeNode<iType>*&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Delete the node without breaking any rules of the binary search tree.

			\item{Input}

				The node the be deleted.

			\item{Output}

				N/A

			\item{Assumptions}

				Assumes the node is part of a valid binary search tree.

		\end{description}
	\item{\textsc{getPredecessor}}
		\begin{lstlisting}
			void getPredecessor(treeNode<iType>*, iType&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Return the right most node of a left child.

			\item{Input}

				The left child of some node.

			\item{Output}

				Places the info from the right most child into the iType parameter.

			\item{Assumptions}

				Assumes the node is a valid node.

		\end{description}
	\item{\textsc{print}}
		\begin{lstlisting}
			void print(treeNode<iType>*, ostream&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}
				
				The recursive part of the print function, prints the tree inorder by printing the left child, the head,
				and then the right child.

			\item{Input}

				A node to be printed and an ostream object to print to.

			\item{Output}

				Prints all the values below the given node as well as the node using recursion.

			\item{Assumptions}
			
				Assumes the same as printTree as well as assuming the node is a valid node or NULL.

		\end{description}
	\item{\textsc{destroy}}
		\begin{lstlisting}
			void destroy(treeNode<iType>*&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

				Recursively deallocate all values in the tree.

			\item{Input}

				A node pointer.

			\item{Output}

				N/A

			\item{Assumptions}

				Assumes the node pointer points to a valid node or is NULL.

		\end{description}
	\item{\textsc{copyTree}}
		\begin{lstlisting}
			void copyTree(treeNode<iType>*&, treeNode<iType>*);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{preOrder}}
		\begin{lstlisting}
			void preOrder(treeNode<iType>*&, queue<iType>&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}
				
				Initialize the given queue with the values of the given tree traversed using pre-order traversal.

			\item{Input}

				A valid node pointer and an empty queue.

			\item{Output}

				Set the values of the queue to the pre-order traversal of the tree.

			\item{Assumptions}

				Assumes the queue is empty and the node pointer points to a valid node or is NULL.

		\end{description}
	\item{\textsc{inOrder}}
		\begin{lstlisting}
			void inOrder(treeNode<iType>*&, queue<iType>&);
		\end{lstlisting}
		\begin{description}

		\item{Purpose}
			
			Initialize the given queue with the values of the given tree traversed using in-order traversal.

		\item{Input}

			A valid node pointer and an empty queue.

		\item{Output}

			Set the values of the queue to the in-order traversal of the tree.

		\item{Assumptions}

			Assumes the queue is empty and the node pointer points to a valid node or is NULL.

		\end{description}
	\item{\textsc{postOrder}}
		\begin{lstlisting}
			void postOrder(treeNode<iType>*&, queue<iType>&);
		\end{lstlisting}
		\begin{description}

		\item{Purpose}
			
			Initialize the given queue with the values of the given tree traversed using post-order traversal.

		\item{Input}

			A valid node pointer and an empty queue.

		\item{Output}

			Set the values of the queue to the post-order traversal of the tree.

		\item{Assumptions}

			Assumes the queue is empty and the node pointer points to a valid node or is NULL.

		\end{description}

\end{description}
\subsection{user.h}
\begin{description}
	\item{\textsc{getName}}
		\begin{lstlisting}
			string getName() const
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{getPass}}
		\begin{lstlisting}
			string getPass() const
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{setName}}
		\begin{lstlisting}
			void setName( string& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{setPass}}
		\begin{lstlisting}
			void setPass( string& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

	\item{\textsc{operator>}}
		\begin{lstlisting}
			bool operator>( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator<}}
		\begin{lstlisting}
			bool operator<( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator>=}}
		\begin{lstlisting}
			bool operator>=( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator<=}}
		\begin{lstlisting}
			bool operator<=( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator==}}
		\begin{lstlisting}
			bool operator==( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

\end{description}
\subsection{part1.cpp}
\begin{description}

	\item{\textsc{readFile}}
		\begin{lstlisting}
			bool readFile( string fileName, binaryTree<user>& tree );
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{storeTree}}
		\begin{lstlisting}
			void storeTree( binaryTree<user>& tree, oType order, string fileName );
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{promptForMenu}}
		\begin{lstlisting}
			menuChoice promptForMenu();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%       PART 2      %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{heap.h}
\begin{description}

	\item{\textsc{reheapDown}}
		\begin{lstlisting}
			void reheapDown(int root, int bottom);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{reheapUp}}
		\begin{lstlisting}
			void reheapUp(int root, int bottom);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{swap}}
		\begin{lstlisting}
			void swap(ItemType &a, ItemType &b);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
\subsection{pqueue.h}
\begin{description}

	\item{\textsc{makeEmpty}}
		\begin{lstlisting}
			void makeEmpty();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isEmpty}}
		\begin{lstlisting}
			bool isEmpty() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isFull}}
		\begin{lstlisting}
			bool isFull() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{enqueue}}
		\begin{lstlisting}
			void enqueue(ItemType newItem);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{dequeue}}
		\begin{lstlisting}
			void dequeue(ItemType& item);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
\subsection{U\_PQType.h}
\begin{description}

	\item{\textsc{U\_PQType}}
		\begin{lstlisting}
			U_PQType(int);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{Remove}}
		\begin{lstlisting}
			void Remove(ItemType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{Update}}
		\begin{lstlisting}
			void Update(ItemType, ItemType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{printTree}}
		\begin{lstlisting}
			void printTree(std::ostream&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
\subsection{part2.cpp}
\begin{description}
	\item{\textsc{readFile}}
		\begin{lstlisting}
			bool readFile( string fileName, U_PQType<int>* &tree);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{promptForMenu}}
		\begin{lstlisting}
			menuChoice promptForMenu();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

\end{description}
\section{Bugs and Errors}

\section{What was Learned}

\section{Division of Labor}

\section{Extra Credit}

\end{document}
