\documentclass[pdftex, 12pt]{article}

\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{fullpage}
\usepackage{color}
\usepackage{amsmath}
\usepackage[pdftex,bookmarks=true,colorlinks=true,linkcolor=blue]{hyperref}
\usepackage{subfig}

%this sets the line at the header
\setlength{\headheight}{15.2pt}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

% This is all for formatting and making the Table of Contents according to 
% spec. Don't play with it.
\makeatletter
\renewcommand\l@section[2]{%
  \ifnum \c@tocdepth >\z@
    \addpenalty\@secpenalty
    \addvspace{1.0em \@plus\p@}%
    \setlength\@tempdima{1.5em}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
      \leavevmode \bfseries
      \advance\leftskip\@tempdima
      \hskip -\leftskip
      #1\nobreak\ 
      \leaders\hbox{$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}
     \hfil \nobreak\hb@xt@\@pnumwidth{\hss #2}\par
    \endgroup
  \fi}
\makeatother



\begin{document}

%import the title page
\input{./title.tex}

%headers, footers, and table of contents
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection}}
\rhead{Page \thepage\ of \pageref{LastPage}}
\lhead{}
\lfoot{CS 302 | Spring 2010}
\cfoot{}
\renewcommand{\footrulewidth}{0.4pt}

\tableofcontents

%\listoffigures
\newpage

\lhead{Joshua Gleason \& Josiah Humphrey}
\rhead{Page \thepage\ of \pageref{LastPage}}
\rfoot{Section\ \rightmark}
\cfoot{}
\lfoot{CS 302 | Spring 2010}
\renewcommand{\footrulewidth}{0.4pt}

\section{Introduction}

In this programming assignment, we continued and built upon image processing. We took out previous programming
assignment and added more functionality. Our goals were to represent the regions found by connected components in a list
and to compute a number of useful properties to characterize their position, orientation, shape, and intensity. This was
a challenge that tested our ability to understand the data structures and image processing. We were also asked to use our
skills to manipulate items in lists, use templates, and learn about feature extraction and classification. 

In this assignment, we learned about geometric properties of objects and how to objectively classify them using
mathematical formulas. We were able to implement the equations that found various geometric properties of objects found
in images. Since this is a introduction to image processing, we were only asked to implement geometric and intensity
properties only. Using more advanced techniques we could have done more complicated things.

To calculate these properties, we used a technique from probability theory called moments. A moment is defined as 
\[
M_{p,q} = \sum_{i,j \in R} i^{p} j^{q}
\]

This was the basis for many of our calculations and was implemented as a generic function that would take any numbers
for $p$ and $q$.

\section{Use of Code}

The use of this code should be fairly straight forward. The main menu is easy to understand, just select the option you
want and hit enter. To load images into the programs image registers, you can either do it with the menu option, or on
the command line. To load images on the command line, just enter them as arguments. For instance, you could do \texttt{\$
./main.out images/hubble1.pgm}. You can enter as many images as you want on the command line like so: \texttt{\$
./main.out images/hubble1.pgm images/hubble2.pgm images/hubble3.pgm}

To classify the regions in an image, you need to choose the classify region option in the menu. Once you do this, you
will be able to choose which of the classifiers you would like to do. You can do multiple things to the same image. Once
you are done classifying the image, make sure you choose the save image option that is in that sub-menu to save all of
the changes. You will then need to save the image at the top of the main menu in order to output the image. 

One note about the classifiers. There are minimum and maximum values for each function, but to make them easier to use,
if the user inputs bounds that are below the minimum and/or above the maximum, it defaults to the minimum and/or maximum
value respectively. This was done to create a more user friendly program that is capable of accepting data that the
user intends. For instance, if the user wants to include the maximum size, you can just enter "99999999" and it will
interpret that input as a maximum value, but the program will automatically make that input sane for the environment.


\section{Functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%       PART 1      %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{binaryTree.h}
\begin{description}

	\item{\textsc{binaryTree}}
		\begin{lstlisting}
			binaryTree();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{~binaryTree}}
		\begin{lstlisting}
			~binaryTree();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator=}}
		\begin{lstlisting}
			void operator=(const binaryTree<iType>&);
		\end{lstlisting}

		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

	\item{\textsc{makeEmpty}}
		\begin{lstlisting}
			void makeEmpty();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isEmpty}}
		\begin{lstlisting}
			bool isEmpty() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isFull}}
		\begin{lstlisting}
			bool isFull() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{numberOfNodes}}
		\begin{lstlisting}
			int numberOfNodes() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{retrieveItem}}
		\begin{lstlisting}
			bool retrieveItem(iType&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{insertItem}}
		\begin{lstlisting}
			void insertItem(iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{deleteItem}}
		\begin{lstlisting}
			void deleteItem(iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{resetTree}}
		\begin{lstlisting}
			void resetTree(oType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{getNextItem}}
		\begin{lstlisting}
			bool getNextItem(iType&, oType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{printTree}}
		\begin{lstlisting}
			void printTree(ostream&) const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{countNodes}}
		\begin{lstlisting}
			int countNodes(treeNode<iType>*);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{retrieve}}
		\begin{lstlisting}
			bool retrieve(treeNode<iType>*, iType&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{insert}}
		\begin{lstlisting}
			void insert(treeNode<iType>*&, iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{deleteOut}}
		\begin{lstlisting}
			void deleteOut(treeNode<iType>*&, iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{deleteNode}}
		\begin{lstlisting}
			void deleteNode(treeNode<iType>*&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{getPredecessor}}
		\begin{lstlisting}
			void getPredecessor(treeNode<iType>*, iType&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{print}}
		\begin{lstlisting}
			void print(treeNode<iType>*, ostream&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{destroy}}
		\begin{lstlisting}
			void destroy(treeNode<iType>*&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{copyTree}}
		\begin{lstlisting}
			void copyTree(treeNode<iType>*&, treeNode<iType>*);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{countNodes}}
		\begin{lstlisting}
			void countNodes(treeNode<iType>*&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{preOrder}}
		\begin{lstlisting}
			void preOrder(treeNode<iType>*&, queue<iType>&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{inOrder}}
		\begin{lstlisting}
			void inOrder(treeNode<iType>*&, queue<iType>&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{postOrder}}
		\begin{lstlisting}
			void postOrder(treeNode<iType>*&, queue<iType>&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

\end{description}
\subsection{user.h}
\begin{description}
	\item{\textsc{getName}}
		\begin{lstlisting}
			string getName() const
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{getPass}}
		\begin{lstlisting}
			string getPass() const
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{setName}}
		\begin{lstlisting}
			void setName( string& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{setPass}}
		\begin{lstlisting}
			void setPass( string& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

	\item{\textsc{operator>}}
		\begin{lstlisting}
			bool operator>( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator<}}
		\begin{lstlisting}
			bool operator<( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator>=}}
		\begin{lstlisting}
			bool operator>=( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator<=}}
		\begin{lstlisting}
			bool operator<=( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator==}}
		\begin{lstlisting}
			bool operator==( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

\end{description}
\subsection{part1.cpp}
\begin{description}

	\item{\textsc{readFile}}
		\begin{lstlisting}
			bool readFile( string fileName, binaryTree<user>& tree );
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{storeTree}}
		\begin{lstlisting}
			void storeTree( binaryTree<user>& tree, oType order, string fileName );
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{promptForMenu}}
		\begin{lstlisting}
			menuChoice promptForMenu();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%       PART 2      %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{heap.h}
\begin{description}

	\item{\textsc{reheapDown}}
		\begin{lstlisting}
			void reheapDown(int root, int bottom);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{reheapUp}}
		\begin{lstlisting}
			void reheapUp(int root, int bottom);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{swap}}
		\begin{lstlisting}
			void swap(ItemType &a, ItemType &b);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
\subsection{pqueue.h}
\begin{description}

	\item{\textsc{makeEmpty}}
		\begin{lstlisting}
			void makeEmpty();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isEmpty}}
		\begin{lstlisting}
			bool isEmpty() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isFull}}
		\begin{lstlisting}
			bool isFull() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{enqueue}}
		\begin{lstlisting}
			void enqueue(ItemType newItem);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{dequeue}}
		\begin{lstlisting}
			void dequeue(ItemType& item);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
\subsection{U_PQType.h}
\begin{description}

	\item{\textsc{U_PQType}}
		\begin{lstlisting}
			U_PQType(int);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{Remove}}
		\begin{lstlisting}
			void Remove(ItemType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{Update}}
		\begin{lstlisting}
			void Update(ItemType, ItemType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{printTree}}
		\begin{lstlisting}
			void printTree(std::ostream&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
\subsection{part2.cpp}
\begin{description}
	\item{\textsc{readFile}}
		\begin{lstlisting}
			bool readFile( string fileName, U_PQType<int>* &tree);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{promptForMenu}}
		\begin{lstlisting}
			menuChoice promptForMenu();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

	\item{\textsc{operator<=}}
		\begin{description}
				\begin{lstlisting}
					bool operator<=(const RegionType<pType> &rhs) const;
				\end{lstlisting}

			\item{Purpose}

				Overloaded function for less than or equal

			\item{Input}

				A RegionType object to compare to

			\item{Output}

				Bool value based on the output of the comparison

			\item{Assumption}

				None

		\end{description}
		\section{Bugs and Errors}

		During the creating of this program, there was one single bug that took a very, very long time to track down, following
		is a detailed explanation of the bug and the methods used to track down and repair it.

		The problem originally manifested itself as a segmentation fault when the choice to 'Classify Regions' was selected in
		the main menu.  At first I looked through the classifyRegions function for any obvious problems, after that search came
		up empty I began using the GDB debugger to track down the fatal error.

		The first thing I needed to know was where the actual error was occurring, so I executed the program in GDB.  After the
		re-creating the segmentation fault I found that the crash was occurring a conditional statement inside of the $==$
		operator overload function inside of the Region Type class.  By examining parameters passed to the function I discovered
		that the right hand side was actually an invalid value, printing the address of the parameter I found the value was
		actually NULL.  This seemed very strange, so I used GDB's backtrace command, which indicated that the comparison was
		taking place in the deleteItem function of the sortedList class or more specific the list of regions for the image.

		Before debugging further, I pondered the recently acquired information and came to a hypothesis.  I believed that the
		deleteItem function was not finding the value that it was passed even thought the RegionType values were being directly
		taken from the list of regions.  This was the only way I could conceive the $==$ operator being passed NULL from
		deleteItem.  Some more debugging was definitely needed to verify this claim and also answer some other questions if this
		was the case.

		After setting a breakpoint in the deleteItem function I ran the program and selected the Classify Regions option.  The
		program paused at the first breakpoint where I obtained some very interesting information about the RegionType in
		question.  I ran the command \texttt{print *this} in GDB so that I could quickly see all of the private members of the
		current object.  To my surprise one of the values was definitely invalid, which may explain why the $==$ operator never
		returned true, even if the values had the same data members.  What would happen if you tried to compare two invalid double
		values, even if they were copies of one another?  I had to determine the answer to this question.  By continuing execution
		I found where two regions had all the same valid data members and when finished the $==$ function I discovered that the
		returned value was false, which would explain why deleteItem never found the right value.

		At this point I was feeling pretty good about having narrowed down the problem to a calculation issue, but why was I
		getting invalid values for eccentricity for some of the regions?  To determine this I set a breakpoint in the
		setData function of RegionType and recreated the error yet again.  To my surprise the first region had some invalid
		values, but I also noticed that the value for lambdaMin was zero; I thought I recalled the eccentricity requiring
		dividing by lambdaMin, so I checked it out.  I verified that this was the indeed true, so I decided to find why
		lambdaMin was being set to zero.  After using similar techniques I discovered that lambdaMin was zero because the central
		moment was returning zero for regions of width or height one.  I determined that the calculation was correct because I
		had received the same value when I did it by hand, so the problem wasn't actually a coding problem, it was a problem with
		the function equation.  To fix this problem, I added an exception to prevent dividing by zero by adding one to the
		numerator and denominator if the central moment of 1,1 returned zero.  This single bug took nearly two hours to track
		down, but after discovering the cause I at least feel much more compentent with GDB.


		\section{What was Learned}

		In this lab, the students learned about classifying regions in images. The students also learned about moments from
		probability theory. The students combined these aspects of problem solving to come up with a solution to make
		probabilistic calculations on regions found in an image.  The students used these tools to better understand the
		application and development of image processing. The students were able to combine these tools successfully to implement
		a working program that can correctly classify regions found within an image. To store the regions unique data, the
		students implemented a sorted list and an unsorted list that contained the $x,y$ coordinates of the regions and a sorted
		list of the regions and their associated data. This helped the students better understand data structures and helped the
		students to know how to implement and develop a data structure. Since it was suggested to template these data
		structures, the students choose to do this and had a template for the unsorted and sorted list types. This proved to
		further the student's knowledge and prowess of templates in C++.  The students also learned how to embed other objects
		into objects. This was done with the region object that had embedded in it an unsorted list to hold the region pixel
		locations. This was not too hard, but still taught the students how to embed objects in objects.

		\section{Division of Labor}

		For this assignment, the labor was divided equally among the partners. Each student contributed equally to the
		production and development of the code. The work was divided after the assignment was announced, and the students each
		had about the same work to be done.

		Joshua was responsible for writing the sorted list and Josiah wrote the unsorted list.  For the calculations Josiah
		wrote most of the functions in RegionType dealing with moment and central moments and Joshua wrote the intensity
		calculations.  Joshua also wrote most of the extra curses based code in driver including printSummary, both students
		contributed equally to the classifyRegions function.  The documentation was split evenly while both students put their
		own part into most of the sections and reviewed all of the sections.

		\section{Extra Credit}
		\begin{description}
			\item{Sorted List}

				The implementation for the sorted list was completed and done using templates. The lists were some of the first
				things that were templated because they were needed in order to complete the rest of the assignment. The sorted
				list uses a link list implementation and keeps the list sorted. While a array based implementation would have
				been faster to search and retrieve items, we choose a linked list implementation because we would not know how
				large the list would need to be. Therefore the only possible implementation that is efficient is a linked list
				implementation of the sorted list.

			\item{Unsorted List}

				The implementation for the unsorted list was completed and done using templates. The lists were some of the
				first things that were templated because they were needed in order to complete the rest of the assignment. The
				unsorted list uses a link list implementation and inserts at the fastest possible place because it is unsorted
				and it does not matter where the nodes are inserted. While a array based implementation would have been faster
				to search and retrieve items, we choose a linked list implementation because we would not know how large the
				list would need to be. Therefore the only possible implementation that is efficient is a linked list
				implementation of the unsorted list.

		\end{description}

		\end{document}
