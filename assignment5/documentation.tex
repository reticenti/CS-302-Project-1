\documentclass[pdftex, 12pt]{article}

\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{fullpage}
\usepackage{color}
\usepackage{amsmath}
\usepackage[pdftex,bookmarks=true,colorlinks=true,linkcolor=blue]{hyperref}
\usepackage{subfig}

%this sets the line at the header
\setlength{\headheight}{15.2pt}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

% This is all for formatting and making the Table of Contents according to 
% spec. Don't play with it.
\makeatletter
\renewcommand\l@section[2]{%
  \ifnum \c@tocdepth >\z@
    \addpenalty\@secpenalty
    \addvspace{1.0em \@plus\p@}%
    \setlength\@tempdima{1.5em}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
      \leavevmode \bfseries
      \advance\leftskip\@tempdima
      \hskip -\leftskip
      #1\nobreak\ 
      \leaders\hbox{$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}
     \hfil \nobreak\hb@xt@\@pnumwidth{\hss #2}\par
    \endgroup
  \fi}
\makeatother



\begin{document}

%import the title page
\input{./title.tex}

%headers, footers, and table of contents
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection}}
\rhead{Page \thepage\ of \pageref{LastPage}}
\lhead{}
\lfoot{CS 302 | Spring 2010}
\cfoot{}
\renewcommand{\footrulewidth}{0.4pt}

\tableofcontents

%\listoffigures
\newpage

\lhead{Joshua Gleason \& Josiah Humphrey}
\rhead{Page \thepage\ of \pageref{LastPage}}
\rfoot{Section\ \rightmark}
\cfoot{}
\lfoot{CS 302 | Spring 2010}
\renewcommand{\footrulewidth}{0.4pt}

\section{Introduction}

\section{Use of Code}

\section{Functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%       PART 1      %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{binaryTree.h}
\begin{description}

	\item{\textsc{binaryTree}}
		\begin{lstlisting}
			binaryTree();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{~binaryTree}}
		\begin{lstlisting}
			~binaryTree();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator=}}
		\begin{lstlisting}
			void operator=(const binaryTree<iType>&);
		\end{lstlisting}

		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

	\item{\textsc{makeEmpty}}
		\begin{lstlisting}
			void makeEmpty();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isEmpty}}
		\begin{lstlisting}
			bool isEmpty() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isFull}}
		\begin{lstlisting}
			bool isFull() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{numberOfNodes}}
		\begin{lstlisting}
			int numberOfNodes() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{retrieveItem}}
		\begin{lstlisting}
			bool retrieveItem(iType&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{insertItem}}
		\begin{lstlisting}
			void insertItem(iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{deleteItem}}
		\begin{lstlisting}
			void deleteItem(iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{resetTree}}
		\begin{lstlisting}
			void resetTree(oType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{getNextItem}}
		\begin{lstlisting}
			bool getNextItem(iType&, oType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{printTree}}
		\begin{lstlisting}
			void printTree(ostream&) const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{countNodes}}
		\begin{lstlisting}
			int countNodes(treeNode<iType>*);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{retrieve}}
		\begin{lstlisting}
			bool retrieve(treeNode<iType>*, iType&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{insert}}
		\begin{lstlisting}
			void insert(treeNode<iType>*&, iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{deleteOut}}
		\begin{lstlisting}
			void deleteOut(treeNode<iType>*&, iType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{deleteNode}}
		\begin{lstlisting}
			void deleteNode(treeNode<iType>*&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{getPredecessor}}
		\begin{lstlisting}
			void getPredecessor(treeNode<iType>*, iType&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{print}}
		\begin{lstlisting}
			void print(treeNode<iType>*, ostream&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{destroy}}
		\begin{lstlisting}
			void destroy(treeNode<iType>*&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{copyTree}}
		\begin{lstlisting}
			void copyTree(treeNode<iType>*&, treeNode<iType>*);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{countNodes}}
		\begin{lstlisting}
			void countNodes(treeNode<iType>*&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{preOrder}}
		\begin{lstlisting}
			void preOrder(treeNode<iType>*&, queue<iType>&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{inOrder}}
		\begin{lstlisting}
			void inOrder(treeNode<iType>*&, queue<iType>&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{postOrder}}
		\begin{lstlisting}
			void postOrder(treeNode<iType>*&, queue<iType>&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

\end{description}
\subsection{user.h}
\begin{description}
	\item{\textsc{getName}}
		\begin{lstlisting}
			string getName() const
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{getPass}}
		\begin{lstlisting}
			string getPass() const
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{setName}}
		\begin{lstlisting}
			void setName( string& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{setPass}}
		\begin{lstlisting}
			void setPass( string& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

	\item{\textsc{operator>}}
		\begin{lstlisting}
			bool operator>( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator<}}
		\begin{lstlisting}
			bool operator<( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator>=}}
		\begin{lstlisting}
			bool operator>=( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator<=}}
		\begin{lstlisting}
			bool operator<=( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{operator==}}
		\begin{lstlisting}
			bool operator==( const user& rhs )
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

\end{description}
\subsection{part1.cpp}
\begin{description}

	\item{\textsc{readFile}}
		\begin{lstlisting}
			bool readFile( string fileName, binaryTree<user>& tree );
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{storeTree}}
		\begin{lstlisting}
			void storeTree( binaryTree<user>& tree, oType order, string fileName );
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{promptForMenu}}
		\begin{lstlisting}
			menuChoice promptForMenu();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%       PART 2      %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{heap.h}
\begin{description}

	\item{\textsc{reheapDown}}
		\begin{lstlisting}
			void reheapDown(int root, int bottom);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{reheapUp}}
		\begin{lstlisting}
			void reheapUp(int root, int bottom);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{swap}}
		\begin{lstlisting}
			void swap(ItemType &a, ItemType &b);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
\subsection{pqueue.h}
\begin{description}

	\item{\textsc{makeEmpty}}
		\begin{lstlisting}
			void makeEmpty();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isEmpty}}
		\begin{lstlisting}
			bool isEmpty() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{isFull}}
		\begin{lstlisting}
			bool isFull() const;
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{enqueue}}
		\begin{lstlisting}
			void enqueue(ItemType newItem);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{dequeue}}
		\begin{lstlisting}
			void dequeue(ItemType& item);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
\subsection{U_PQType.h}
\begin{description}

	\item{\textsc{U_PQType}}
		\begin{lstlisting}
			U_PQType(int);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{Remove}}
		\begin{lstlisting}
			void Remove(ItemType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{Update}}
		\begin{lstlisting}
			void Update(ItemType, ItemType);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{printTree}}
		\begin{lstlisting}
			void printTree(std::ostream&);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
\end{description}
\subsection{part2.cpp}
\begin{description}
	\item{\textsc{readFile}}
		\begin{lstlisting}
			bool readFile( string fileName, U_PQType<int>* &tree);
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}
	\item{\textsc{promptForMenu}}
		\begin{lstlisting}
			menuChoice promptForMenu();
		\end{lstlisting}
		\begin{description}

			\item{Purpose}

			\item{Input}

			\item{Output}

			\item{Assumptions}

		\end{description}

\end{description}
\section{Bugs and Errors}

\section{What was Learned}

\section{Division of Labor}

\section{Extra Credit}

\end{document}
